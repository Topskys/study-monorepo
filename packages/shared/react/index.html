<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React</title>

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #app {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <div id="app"></div>
    <!-- <script src="./index.js"></script> -->

    <!-- <script>
        /**
         * MessageChannel API 设计初衷是用来在不同的上下文（例如主线程和Worker线程）之间进行跨域通信的，
         * 如web worker、iframe，它提供了两个端口，使得消息可以在两个独立的线程之间双向传递。 
         * 
         * 在React中基于MessageChannel渲染实现工作单元的执行，如浏览器不支持MessageChannel，将会使用setTimeout代替。
         * MessageChannel API 
         * 
         * 为什么要用MessageChannel而不是setTimeout或者requestIdleCallback？
         * MessageChannel API 相比于setTimeout或requestIdleCallback有几个优势：
         * 1. 更高的优先级：MessageChannel的消息通常有较高的执行优先级，这意味着它们可能会在主线程空闲时优先被处理。
         * 2. 更好的性能：MessageChannel可以更有效地利用主线程的时间，因为它可以在主线程空闲时立即执行，而不会像setTimeout那样需要等待下一个事件循环。
         * 3. 更好的兼容性：MessageChannel在大多数现代浏览器中都得到了支持，而setTimeout和requestIdleCallback在某些浏览器中可能不被支持。
         * 4. 更好的控制：使用MessageChannel可以更精确地控制消息的发送和接收，例如可以在不同的线程之间传递复杂的对象。
         * 总的来说，MessageChannel提供了一个更高效、更灵活的跨线程通信机制，特别是在需要高性能和精确控制的场景下。
         */
        const channel = new MessageChannel();
        const { port1, port2 } = channel;

        // 端口1的监听消息
        port1.onmessage = (e) => {
            // 接收端口2的消息
            console.log(e.data);
        }

        // 向端口2发送消息
        port2.postMessage('hello');
    </script> -->

    <script src='./requestIdleCallback.js'></script>
</body>

</html>